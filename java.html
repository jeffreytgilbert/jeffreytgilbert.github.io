<html><head>
<style>
<!--
* {
	font-family: Helvetica, Arial, sans-serif;
}
body {
	font-family: Helvetica, Arial, sans-serif;
	font-weight: 400;
	font-style: normal;
	font-size: 12px;
	line-height: 21px;
	max-width: 760px;
	padding: 21px;
	margin: 0 auto;
}
h1 {
	font-family: inherit;
	font-weight: 600;
	font-style: inherit;
	font-size: 51px;
	line-height: 63px;
	margin-top: 21px;
	margin-bottom: 0px;
}
h2 {
	font-family: inherit;
	font-weight: 600;
	font-style: inherit;
	font-size: 31px;
	line-height: 42px;
	margin-top: 21px;
	margin-bottom: 21px;
}
h3 {
	font-family: inherit;
	font-weight: 600;
	font-style: inherit;
	font-size: 19px;
	line-height: 21px;
	margin-top: 21px;
	margin-bottom: 0px;
}
h4 {
	font-family: inherit;
	font-weight: 600;
	font-style: inherit;
	font-size: 12px;
	line-height: 21px;
	margin-top: 21px;
	margin-bottom: 0px;
}
h5 {
	font-family: inherit;
	font-weight: 400;
	font-style: italic;
	font-size: 12px;
	line-height: 21px;
	margin-top: 21px;
	margin-bottom: 0px;
}
p, ul, ol, pre, table, blockquote {
	margin-top: 0px;
	margin-bottom: 21px;
}
ul ul, ol ol, ul ol, ol ul {
	margin-top: 0;
	margin-bottom: 0;
}
hr {
	border: 1px solid;
	margin: -1px 0;
}
b, strong, em, small, code {
	line-height: 1;
}
sup {
	line-height: 0;
	position: relative;
	vertical-align: baseline;
	top: -0.5em;
}
sub {
	bottom: -0.25em;
}
a {
	color: #268ED9;
}
-->
</style>
  </head>
  <body>
    <h1>A summary of some of the tools we use</h1>
    <p>We use git for source control, maven for building and Bamboo to provide continuous
building and artifact generation.  We also use Atlassian Bidbucket (formally called stash)
for code-reviews.</p>

    <table border="1" cellpadding="2" cellspacing="0">
      <tbody><tr><th>tool</th> <th>Description</th>
      </tr><tr>
        <td><a href="https://git-scm.com/doc">git</a>
        </td><td>used for source/version control</td>
      </tr>
      <tr>
        <td><a href="https://maven.apache.org/">maven</a>
        </td><td>used for building source code both locally and on the build server</td>
      </tr>
      <tr>
        <td><a href="https://www.atlassian.com/software/bamboo">Atlassian Bamboo</a>
        </td><td>continuous building of source code upon git commit and pushes to remote</td>
      </tr>
      <tr>
        <td><a href="https://www.atlassian.com/software/bitbucket">Atlassian Bitbucket</a>
        </td><td>formally called stash, used for code reviews (and viewing source code)</td>
      </tr>
    </tbody></table>
    <h4>A brief description of the process we use for git</h4>
    <p>
      We have our source code distributed among many different git repositories. Some of those
repositories have the capability to create independently deployable artifacts and our
operations department handles the deployments and rollout to production.
    </p>
    <p>
      In git we don't ever use a "development" branch.  Each repository has a "main" which
      each developer creates a feature branch off of to do their feature work (or for
      working on production issues).  At any one time there will be many, many feature
      branches with concurrent development ongoing for any given repository.  When a
      developer believes their code is complete and ready for QA testing they do a git
      rebase -i command to squash their commits down to a single commit (with just 1 SHA1
      hash) and then they push it up to the remote.  At this time bamboo will sense a
      commit on the feature branch and kick off an automatic build of that feature branch.
      The developer also has the option to manually kick off the bamboo build if they
      catch it before bamboo recognized the push to remote and started the automatic
      build.  This builds a SNAPSHOT artifact named after the feature branch which QA uses
      to deploy to their test environment and run tests against.
    </p>
    <p>
      Once the code passes QA testing the feature branch is rebased against the target
      release branch (if one does not exist then it's created).  A pull-request is then
      created with the release branch as the target.
    </p>
    <p>
    Once reviewers approve the pull-request the feature branch is merged into the release
    branch.  The only type of merges allowed on the release branchs are fast-forward-only
    which is guaranteed to always be the case after a rebase.
    </p>
    <p>
      Once all the required features have been merged into the release branch, a release
      artifact (and a git tag) is generated by kicking off a release on Bamboo.  This has
      the effect of creating a Nexus release artifact, fast-forward merging the release
      branch into master and setting up for the next release by removing the existing
      release branch and creating the next one.
    </p>
    <p>
      The newely created release artifact is what is deployed to production by the
      operations department.
    </p>
      <h4>The main takeaways from this abridged process discussion is our use of git rebase
      and git merge with --ff-only.</h4>  You could find information on these commands on the
      git docs pages.
    <p></p>

    <h1>Conversant training videos</h1>
    <table border="1" cellpadding="2" cellspacing="0">
      <tbody><tr>
        <td><a href="https://www.youtube.com/channel/UCl6vKnO1Uzmv_OAJhwuCl-g">Conversant Engineering</a></td>
      </tr>
      <tr>
        <td><a href="https://www.youtube.com/watch?v=jVMOgQgYzWU">Smashing Atomics: Concurrency in Java</a></td>
      </tr>
      <tr>
        <td><a href="https://youtu.be/ePBsKjfNmxs">Tuning the Java Garbage Collector</a></td>
      </tr>
    </tbody></table>

    <p>
      <a href="https://github.com/conversant">Conversant GitHub</a> where we have a number of open source projects.
    </p>

    <h1>OpenRTB from IAB</h1>
    <p>We get requests based on the OpenRTB (Json specification) from most of our exchange partners</p>

    <p>
      Currently we're supporting exchanges that talk to us via OpenRTB 2.0, 2.1, 2.2, 2.3,
      the latest is 2.4 but we don't yet have any exchanges migrated to OpenRTB 2.4 yet.
      All of the OpenRTB specification documents describe the communication cycle so
      taking a look at any of them will provide a good understanding of the protocol. Here
      are some links to recent versions of the spec.  One caveat to be aware of while
      looking at these OpenRTB specs, each exchange we do business with (presently there
      are over 30) have exchange-specific modifications or exceptions to the spec.  This
      is actually allowed in the spec by providing extension Objects.
    </p>

    <ul>
      <li><a href="http://www.iab.com/wp-content/uploads/2016/03/OpenRTB-API-Specification-Version-2-4-FINAL.pdf">Latest OpenRTB spec 2.4</a></li>
      <li><a href="http://www.iab.com/wp-content/uploads/2015/05/OpenRTB_API_Specification_Version_2_3_1.pdf">OpenRTB spec 2.3</a></li>
      <li><a href="https://www.iab.com/wp-content/uploads/2015/06/OpenRTBAPISpecificationVersion2_2.pdf">OpenRTB spec 2.2</a></li>
    </ul>
    <h1>Protocol Buffers</h1>
    <p>
      We use Google's Protocol Buffers for some internal messaging.  Also Bid Requests and
      Responses for Google's Ad Exchange (it goes by a couple of names: Doubleclick and
      Adx) uses this messaging mechanism.
    </p>

    <ul>
      <li><a href="https://developers.google.com/protocol-buffers/">General information on Protocol Buffers</a></li> 
      <li><a href="https://developers.google.com/ad-exchange/rtb/start">Google Adx specific bidding</a></li>
      <li><a href="https://developers.google.com/ad-exchange/rtb/downloads/realtime-bidding-proto">Adx bidding spec itself</a></li>
    </ul>


    
  
 
</body></html>
